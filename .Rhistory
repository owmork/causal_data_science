ggdag(schooling_dag, text = FALSE) +
theme_dag_cds() + # custom theme, can be left out
geom_dag_point(color = ggthemr::swatch()[2]) +
geom_dag_text(color = NA) +
geom_dag_label_repel(aes(label = name), size = 6) +
geom_dag_edges(edge_color = "white")
#| echo: false
#| message: false
# Load packages
library(tidyverse)
library(dagitty)
library(ggdag)
# Construct DAG
schooling_dag <- dagify(
exposure = "uni_degree",
outcome = "salary",
uni_degree ~ ability,
salary ~ ability,
salary ~ uni_degree,
coords = list(x = c(uni_degree = 1, salary = 3, ability = 2),
y = c(uni_degree = 1, salary = 1, ability = 2))
)
# Plot DAG
ggdag(schooling_dag, text = FALSE) +
theme_dag_cds() + # custom theme, can be left out
geom_dag_point(color = ggthemr::swatch()[2]) +
geom_dag_text(color = NA) +
geom_dag_label_repel(aes(label = name), size = 6) +
geom_dag_edges(edge_color = "red")
#| echo: false
#| message: false
# Load packages
library(tidyverse)
library(dagitty)
library(ggdag)
# Construct DAG
schooling_dag <- dagify(
exposure = "uni_degree",
outcome = "salary",
uni_degree ~ ability,
salary ~ ability,
salary ~ uni_degree,
coords = list(x = c(uni_degree = 1, salary = 3, ability = 2),
y = c(uni_degree = 1, salary = 1, ability = 2))
)
# Plot DAG
ggdag(schooling_dag, text = FALSE) +
theme_dag_cds() + # custom theme, can be left out
geom_dag_point(color = ggthemr::swatch()[2]) +
geom_dag_text(color = NA) +
geom_dag_label_repel(aes(label = name), size = 6) +
geom_dag_edges(edge_color = "white")
ggthemr::swatch()[2]
ggthemr::swatch()[7]
Collider: $X \rightarrow Z \leftarrow Y$
Knowing their characteristics and idiosyncrasies allows us to identify valid strategies to estimate causal effects. Then, you know which variables you have to include in your analysis and which ones you have to leave out. Because in case you include or exclude the wrong variables, you will end up with a biased results and you are not able to interpret your estimate causally.
# RCT
rct <- dagify(
Y ~ X,
Y ~ Z,
coords = list(x = c(Y = 3, Z = 2, X = 1),
y = c(Y = 1, Z = 0, X = 1))
)
# Plot DAG
ggdag(rct) +
theme_dag_cds() + # custom theme, can be left out
geom_dag_point(color = ggthemr::swatch()[2]) +
geom_dag_text(color = "white") +
geom_dag_edges(edge_color = ggthemr::swatch()[7])
# RCT
rct <- dagify(
Y ~ X,
Y ~ Z,
coords = list(x = c(Y = 3, Z = 2, X = 1),
y = c(Y = 1, Z = 2, X = 1))
)
# Plot DAG
ggdag(rct) +
theme_dag_cds() + # custom theme, can be left out
geom_dag_point(color = ggthemr::swatch()[2]) +
geom_dag_text(color = "white") +
geom_dag_edges(edge_color = ggthemr::swatch()[7])
# Construct DAG
profits_dag <- dagify(
consultant ~ previous_profit,
profit ~ previous_profit,
profit ~ consultant,
coords = list(x = c(consultant = 1, profit = 3, previous_profit = 2),
y = c(consultant = 1, profit = 1, previous_profit = 2))
)
# Plot DAG
ggdag(profits_dag, text = FALSE) +
theme_dag_cds() + # custom theme, can be left out
geom_dag_point(color = ggthemr::swatch()[2]) +
geom_dag_text(color = NA) +
geom_dag_label_repel(aes(label = name), size = 6) +
geom_dag_edges(edge_color = ggthemr::swatch()[7])
ggdag_status(dag_model)
ggdag_status(dag_model) + theme_dag()
knitr::opts_chunk$set(fig.width = 6, fig.asp = 0.618, fig.align = "center", fig.retina = 3, out.width = "75%")
set.seed(11)
options("digits" = 2, "width" = 150)
options(dplyr.summarise.inform = FALSE)
# custom ggplot theme
# colors from TUHH brand identitiy
tuhh_colors <- c("#D0D0CE", "#00C1D4", "#FF4F4F", "#5AFFC5",
"#FFDE36", "#143BFF", "#FF7E15", "#FFAEA2")
# initialise theme
cds_theme <- ggthemr::define_palette(
swatch = tuhh_colors,
gradient = c(lower = "#FFAEA2", upper = "#00C1D4"),
background = "#0F2231",
line = c("#FFFFFF", "#FFFFFF"),
text = c("#FFFFFF", "#FFFFFF"),
gridline = c(ggplot2::alpha("#D0D0CE", 0.2),
ggplot2::alpha("#D0D0CE", 0.4))
)
# set theme
ggthemr::ggthemr(cds_theme, type = "outer")
# source custom DAG theme
source(paste0(here::here(), "/code/dag_theme.R"))
library(tidyverse)
library(dagitty)
library(ggdag)
# Define dependencies and coordinates
schooling_dag_1 <- dagify(
salary ~ uni_degree,
uni_degree ~ ability,
salary ~ ability,
exposure = "uni_degree",
outcome = "salary"
)
# Load packages
library(tidyverse)
library(dagitty)
library(ggdag)
# Define dependencies and coordinates
schooling_dag_1 <- dagify(
salary ~ uni_degree,
uni_degree ~ ability,
salary ~ ability,
exposure = "uni_degree",
outcome = "salary"
)
# Plot DAG
ggdag(schooling_dag_1)
# Load packages
library(tidyverse)
library(dagitty)
library(ggdag)
# Define dependencies and coordinates
schooling_dag_1 <- dagify(
salary ~ uni_degree,
uni_degree ~ ability,
salary ~ ability,
exposure = "uni_degree",
outcome = "salary"
)
# Plot DAG
ggdag(schooling_dag_1) + theme_dag()
'
# Define DAG
schooling_dag_2 <- '
# Define DAG
schooling_dag_2 <- 'dag {
}'
# Plot DAG
ggdag(schooling_dag_2) + theme_dag()
ggdag(schooling_dag_2)
# Define DAG
schooling_dag_2 <- 'dag {
# Define DAG
schooling_dag_2 <- 'dag {
# Get adjustment sets. Because we already specified exposure and outcome when
# constructing the DAG, we do not need to do again. If they were not specified,
# you could do so by explicitly providing arguments ("exposure", "outcome")
adjustmentSets(schooling_dag_1)
#| code-fold: true
# Specify chain structure
chain <- dagify(
Y ~ Z,
Z ~ X,
coords = list(x = c(Y = 3, Z = 2, X = 1),
y = c(Y = 0, Z = 0, X = 0))
)
# Plot DAG
ggdag(chain) +
theme_dag_cds() + # custom theme, can be left out
geom_dag_point(color = ggthemr::swatch()[2]) +
geom_dag_text(color = "white") +
geom_dag_edges(edge_color = ggthemr::swatch()[7])
# Check d-separation between X and Y
dseparated(chain, X = "X", Y = "Y", Z = c())
# Check d-separation between X and Y conditional on Z
dseparated(chain, X = "X", Y = "Y", Z = c("Z"))
dseparated(dag_model, X = "X", Y = "Y")
#| code-fold: true
# create DAG from dagitty
dag_model <- 'dag {
bb="0,0,1,1"
X [exposure,pos="0.075,0.4"]
Y [outcome,pos="0.4,0.4"]
M [pos="0.2,0.4"]
Z1 [pos="0.2,0.2"]
Z2 [pos="0.3,0.5"]
Z3 [pos="0.2,0.6"]
Z4 [pos="0.4,0.6"]
X -> M
M -> Y
X -> Z3
Z1 -> X
Z1 -> Y
Z2 -> Y
Z2 -> Z3
Z3 -> Z4
}
'
# draw DAG
ggdag_status(dag_model) +
guides(fill = "none", color = "none") +  # Disable the legend
theme_dag_cds() + # custom theme, can be left out
geom_dag_edges(edge_color = ggthemr::swatch()[7])
dseparated(dag_model, X = "X", Y = "Y")
dseparated(dag_model, X = "X", Y = "Y", Z = c("M", "Z1"))
dseparated(dag_model, X = "X", Y = "Y", Z = c("M", "Z3"))
dseparated(dag_model, X = "X", Y = "Y", Z = c("M", "Z1", "Z4"))
dseparated(dag_model, X = "X", Y = "Y", Z = c("M", "Z1", "Z2", "Z4"))
# Construct DAG
profits_dag <- dagify(
consultant ~ previous_profit,
profit ~ previous_profit,
profit ~ consultant
)
ggdag(profits_dag)
# Construct DAG
profits_dag <- dagify(
consultant ~ previous_profit,
profit ~ previous_profit,
profit ~ consultant
)
ggdag(profits_dag) + theme_dag()
# Adjustment set
adjustmentSets(profits_dag)
# Adjustment set
adjustmentSets(profits_dag, exposure = "consultant", outcome = "profit")
# Statistical summary of column of previous profits
profits$previous_profit
# Load the data
profits <- readRDS("profits.rds")
profits <- readRDS("content/course_weeks/week_02/profits.rds")
# Statistical summary of column of previous profits
profits$previous_profit
# Statistical summary of column of previous profits
summary(profits$previous_profit)
# Split group into n equally sized groups
profits$group <- ntile(profits$previous_profit, 4)
profits
# Split group into n equally sized groups
profits$group <- ntile(profits$previous_profit, 4)
# Compute mean value and number of observations by group
profits_by_group <- profits |>
# What columns to group by
group_by(group, consultant) |>
# What columns to use for aggregation and what kind of aggregations
summarise(
# Average profit by group
mean_profit = mean(profit)
) |>
# Remove grouping structure
ungroup()
# Number of observations by group
# Show table
print(profits_by_group)
profits_by_group |>
# Convert column values of consultant to headers and take values from
# mean_profit
pivot_wider(
# For each group, we want one row
id_cols = group,
# Values of consultants to headers
names_from = "consultant",
# Take values from 'mean_profit'
values_from = "mean_profit",
# Change names of headers for better readability
names_prefix = "consultant"
)
# Convert to wide format to compute effect
te_by_group <- profits_by_group |>
# Convert column values of consultant to headers and take values from
# mean_profit
pivot_wider(
# For each group, we want one row
id_cols = group,
# Values of consultants to headers
names_from = "consultant",
# Take values from 'mean_profit'
values_from = "mean_profit",
# Change names of headers for better readability
names_prefix = "consultant_"
) |>
# Compute group treatment effect by subtracting mean of untreated units from
# mean of treated units
mutate(te = consultant_1 - consultant_0)
# Show table
print(te_by_group)
# Taking the average of the treatment effect column. Same as weighted mean,
# because group sizes are identical.
mean(te_by_group$te)
# With weighted mean
weighted.mean(te_by_group$te, c(250, 250, 250, 250))
profits
# Naive estimate
profits |>
group_by(consultant) |>
summarise(mean_profit = mean(profit)) |>
ungroup()
# Load packages
library(dagitty)
library(dagitty)
library(ggdag)
library(tidyverse)
# Define dependencies and coordinates
schooling_dag_1 <- dagify(
salary ~ uni_degree,
salary ~ ability,
uni_degree ~ ability,
exposure = "uni_degree",
outcome = "salary"
)
schooling_dag_1 <- dagify(
salary ~ uni_degree,
salary ~ ability,
uni_degree ~ ability,
exposure = "uni_degree",
outcome = "salary"
)
# Define dependencies and coordinates
schooling_dag_1 <- dagify(
salary ~ uni_degree,
salary ~ ability,
uni_degree ~ ability,
exposure = "uni_degree",
outcome = "salary"
)
# Load packages
library(dagitty)
library(ggdag)
library(tidyverse)
# Define dependencies and coordinates
schooling_dag_1 <- dagify(
salary ~ uni_degree,
salary ~ ability,
uni_degree ~ ability,
exposure = "uni_degree",
outcome = "salary"
)
# Plot DAG
ggdag(schooling_dag_1)
# Load packages
library(dagitty)
library(ggdag)
library(tidyverse)
# Define dependencies and coordinates
schooling_dag_1 <- dagify(
salary ~ uni_degree,
salary ~ ability,
uni_degree ~ ability,
exposure = "uni_degree",
outcome = "salary"
)
# Plot DAG
ggdag(schooling_dag_1) + theme_dag()
# Define DAG
schooling_dag_2 <- 'dag {
bb="0,0,1,1"
ability [pos="0.340,0.262"]
salary [outcome,pos="0.448,0.485"]
uni_degree [exposure,pos="0.238,0.488"]
ability -> salary
ability -> uni_degree
uni_degree -> salary
}'
# Plot DAG
ggdag(schooling_dag_2)
# Define DAG
schooling_dag_2 <- 'dag {
bb="0,0,1,1"
ability [pos="0.340,0.262"]
salary [outcome,pos="0.448,0.485"]
uni_degree [exposure,pos="0.238,0.488"]
ability -> salary
ability -> uni_degree
uni_degree -> salary
}'
# Plot DAG
ggdag(schooling_dag_2) + theme_dag()
# Get adjustment sets. Because we already specified exposure and outcome when
# constructing the DAG, we do not need to do again. If they were not specified,
# you could do so by explicitly providing arguments ("exposure", "outcome")
adjustmentSets(schooling_dag_1)
# Check d-separation between X and Y
dseparated(chain, X = "X", Y = "Y", Z = c())
# Check d-separation between X and Y conditional on Z
dseparated(chain, X = "X", Y = "Y", Z = c("Z"))
# Construct DAG
profits_dag <- dagify(
consultant ~ previous_profit,
profit ~ consultant,
profit ~ previous_profit
)
ggdag(profits_dag) + theme_dag()
# Adjustment set
adjustmentSets(profits_dag)
# Adjustment set
adjustmentSets(profits_dag, exposure = "consultant", outcome = "salary")
# Adjustment set
adjustmentSets(profits_dag, exposure = "consultant", outcome = "profit")
profits <- readRDS("profits.rds")
profits <- readRDS("content/course_weeks/week_02/profits.rds")
# Statistical summary of column of previous profits
summary(profits$previous_profit)
profits
# Split group into n equally sized groups
profits$group <- ntile(profits$previous_profit, 4)
profits
# Split group into n equally sized groups
profits$group <- ntile(profits$previous_profit, 4)
# Compute mean value and number of observations by group
profits_by_group <- profits |>
# What columns to group by
group_by(group, consultant) |>
# What columns to use for aggregation and what kind of aggregations
summarise(
# Average profit by group
mean_profit = mean(profit)
# Number of observations by group
) |>
# Remove grouping structure
ungroup()
# Show table
print(profits_by_group)
profits_by_group |>
# Convert column values of consultant to headers and take values from
# mean_profit
pivot_wider(
# For each group, we want one row
id_cols = "group",
# Values of consultants to headers
names_from = "consultant",
# Take values from 'mean_profit'
values_from = "mean_profit",
# Change names of headers for better readability
names_prefix = "consultant_",
)
# Convert to wide format to compute effect
te_by_group <- profits_by_group |>
# Convert column values of consultant to headers and take values from
# mean_profit
pivot_wider(
# For each group, we want one row
id_cols = "group",
# Values of consultants to headers
names_from = "consultant",
# Take values from 'mean_profit'
values_from = "mean_profit",
# Change names of headers for better readability
names_prefix = "consultant_",
) |>
# Compute group treatment effect by subtracting mean of untreated units from
# mean of treated units
mutate(te = consultant_1 - consultant_0)
# Show table
print(te_by_group)
# Taking the average of the treatment effect column. Same as weighted mean,
# because group sizes are identical.
mean(te_by_group$te)
# With weighted mean
weighted.mean(te_by_group$te, w = c(250,250,250,250))
# Split group into n equally sized groups
profits$group <- ntile(profits$previous_profit, 4)
# Compute mean value and number of observations by group
profits_by_group <- profits |>
# What columns to group by
group_by(group, consultant) |>
# What columns to use for aggregation and what kind of aggregations
summarise(
# Average profit by group
mean_profit = mean(profit)
# Number of observations by group
n = n()
# Split group into n equally sized groups
profits$group <- ntile(profits$previous_profit, 4)
# Compute mean value and number of observations by group
profits_by_group <- profits |>
# What columns to group by
group_by(group, consultant) |>
# What columns to use for aggregation and what kind of aggregations
summarise(
# Average profit by group
mean_profit = mean(profit),
# Number of observations by group
n = n()
) |>
# Remove grouping structure
ungroup()
# Show table
print(profits_by_group)
# Naive estimate
profits |>
group_by(consultant) |>
summarise(mean_profit = mean(profit)) |>
ungroup()
