geom_dag_edges(edge_color = ggthemr::swatch()[7])
# Check d-separation between X and Y
dseparated(chain, X = "X", Y = "Y", Z = c())
# Check d-separation between X and Y conditional on Z
dseparated(chain, X = "X", Y = "Y", Z = c("Z"))
dseparated(dag_model, X = "X", Y = "Y")
#| code-fold: true
# create DAG from dagitty
dag_model <- 'dag {
bb="0,0,1,1"
X [exposure,pos="0.075,0.4"]
Y [outcome,pos="0.4,0.4"]
M [pos="0.2,0.4"]
Z1 [pos="0.2,0.2"]
Z2 [pos="0.3,0.5"]
Z3 [pos="0.2,0.6"]
Z4 [pos="0.4,0.6"]
X -> M
M -> Y
X -> Z3
Z1 -> X
Z1 -> Y
Z2 -> Y
Z2 -> Z3
Z3 -> Z4
}
'
# draw DAG
ggdag_status(dag_model) +
guides(fill = "none", color = "none") +  # Disable the legend
theme_dag_cds() + # custom theme, can be left out
geom_dag_edges(edge_color = ggthemr::swatch()[7])
dseparated(dag_model, X = "X", Y = "Y")
dseparated(dag_model, X = "X", Y = "Y", Z = c("M", "Z1"))
dseparated(dag_model, X = "X", Y = "Y", Z = c("M", "Z3"))
dseparated(dag_model, X = "X", Y = "Y", Z = c("M", "Z1", "Z4"))
dseparated(dag_model, X = "X", Y = "Y", Z = c("M", "Z1", "Z2", "Z4"))
# Construct DAG
profits_dag <- dagify(
consultant ~ previous_profit,
profit ~ previous_profit,
profit ~ consultant
)
ggdag(profits_dag)
# Construct DAG
profits_dag <- dagify(
consultant ~ previous_profit,
profit ~ previous_profit,
profit ~ consultant
)
ggdag(profits_dag) + theme_dag()
# Adjustment set
adjustmentSets(profits_dag)
# Adjustment set
adjustmentSets(profits_dag, exposure = "consultant", outcome = "profit")
# Statistical summary of column of previous profits
profits$previous_profit
# Load the data
profits <- readRDS("profits.rds")
profits <- readRDS("content/course_weeks/week_02/profits.rds")
# Statistical summary of column of previous profits
profits$previous_profit
# Statistical summary of column of previous profits
summary(profits$previous_profit)
# Split group into n equally sized groups
profits$group <- ntile(profits$previous_profit, 4)
profits
# Split group into n equally sized groups
profits$group <- ntile(profits$previous_profit, 4)
# Compute mean value and number of observations by group
profits_by_group <- profits |>
# What columns to group by
group_by(group, consultant) |>
# What columns to use for aggregation and what kind of aggregations
summarise(
# Average profit by group
mean_profit = mean(profit)
) |>
# Remove grouping structure
ungroup()
# Number of observations by group
# Show table
print(profits_by_group)
profits_by_group |>
# Convert column values of consultant to headers and take values from
# mean_profit
pivot_wider(
# For each group, we want one row
id_cols = group,
# Values of consultants to headers
names_from = "consultant",
# Take values from 'mean_profit'
values_from = "mean_profit",
# Change names of headers for better readability
names_prefix = "consultant"
)
# Convert to wide format to compute effect
te_by_group <- profits_by_group |>
# Convert column values of consultant to headers and take values from
# mean_profit
pivot_wider(
# For each group, we want one row
id_cols = group,
# Values of consultants to headers
names_from = "consultant",
# Take values from 'mean_profit'
values_from = "mean_profit",
# Change names of headers for better readability
names_prefix = "consultant_"
) |>
# Compute group treatment effect by subtracting mean of untreated units from
# mean of treated units
mutate(te = consultant_1 - consultant_0)
# Show table
print(te_by_group)
# Taking the average of the treatment effect column. Same as weighted mean,
# because group sizes are identical.
mean(te_by_group$te)
# With weighted mean
weighted.mean(te_by_group$te, c(250, 250, 250, 250))
profits
# Naive estimate
profits |>
group_by(consultant) |>
summarise(mean_profit = mean(profit)) |>
ungroup()
# Load packages
library(dagitty)
library(dagitty)
library(ggdag)
library(tidyverse)
# Define dependencies and coordinates
schooling_dag_1 <- dagify(
salary ~ uni_degree,
salary ~ ability,
uni_degree ~ ability,
exposure = "uni_degree",
outcome = "salary"
)
schooling_dag_1 <- dagify(
salary ~ uni_degree,
salary ~ ability,
uni_degree ~ ability,
exposure = "uni_degree",
outcome = "salary"
)
# Define dependencies and coordinates
schooling_dag_1 <- dagify(
salary ~ uni_degree,
salary ~ ability,
uni_degree ~ ability,
exposure = "uni_degree",
outcome = "salary"
)
# Load packages
library(dagitty)
library(ggdag)
library(tidyverse)
# Define dependencies and coordinates
schooling_dag_1 <- dagify(
salary ~ uni_degree,
salary ~ ability,
uni_degree ~ ability,
exposure = "uni_degree",
outcome = "salary"
)
# Plot DAG
ggdag(schooling_dag_1)
# Load packages
library(dagitty)
library(ggdag)
library(tidyverse)
# Define dependencies and coordinates
schooling_dag_1 <- dagify(
salary ~ uni_degree,
salary ~ ability,
uni_degree ~ ability,
exposure = "uni_degree",
outcome = "salary"
)
# Plot DAG
ggdag(schooling_dag_1) + theme_dag()
# Define DAG
schooling_dag_2 <- 'dag {
bb="0,0,1,1"
ability [pos="0.340,0.262"]
salary [outcome,pos="0.448,0.485"]
uni_degree [exposure,pos="0.238,0.488"]
ability -> salary
ability -> uni_degree
uni_degree -> salary
}'
# Plot DAG
ggdag(schooling_dag_2)
# Define DAG
schooling_dag_2 <- 'dag {
bb="0,0,1,1"
ability [pos="0.340,0.262"]
salary [outcome,pos="0.448,0.485"]
uni_degree [exposure,pos="0.238,0.488"]
ability -> salary
ability -> uni_degree
uni_degree -> salary
}'
# Plot DAG
ggdag(schooling_dag_2) + theme_dag()
# Get adjustment sets. Because we already specified exposure and outcome when
# constructing the DAG, we do not need to do again. If they were not specified,
# you could do so by explicitly providing arguments ("exposure", "outcome")
adjustmentSets(schooling_dag_1)
# Check d-separation between X and Y
dseparated(chain, X = "X", Y = "Y", Z = c())
# Check d-separation between X and Y conditional on Z
dseparated(chain, X = "X", Y = "Y", Z = c("Z"))
# Construct DAG
profits_dag <- dagify(
consultant ~ previous_profit,
profit ~ consultant,
profit ~ previous_profit
)
ggdag(profits_dag) + theme_dag()
# Adjustment set
adjustmentSets(profits_dag)
# Adjustment set
adjustmentSets(profits_dag, exposure = "consultant", outcome = "salary")
# Adjustment set
adjustmentSets(profits_dag, exposure = "consultant", outcome = "profit")
profits <- readRDS("profits.rds")
profits <- readRDS("content/course_weeks/week_02/profits.rds")
# Statistical summary of column of previous profits
summary(profits$previous_profit)
profits
# Split group into n equally sized groups
profits$group <- ntile(profits$previous_profit, 4)
profits
# Split group into n equally sized groups
profits$group <- ntile(profits$previous_profit, 4)
# Compute mean value and number of observations by group
profits_by_group <- profits |>
# What columns to group by
group_by(group, consultant) |>
# What columns to use for aggregation and what kind of aggregations
summarise(
# Average profit by group
mean_profit = mean(profit)
# Number of observations by group
) |>
# Remove grouping structure
ungroup()
# Show table
print(profits_by_group)
profits_by_group |>
# Convert column values of consultant to headers and take values from
# mean_profit
pivot_wider(
# For each group, we want one row
id_cols = "group",
# Values of consultants to headers
names_from = "consultant",
# Take values from 'mean_profit'
values_from = "mean_profit",
# Change names of headers for better readability
names_prefix = "consultant_",
)
# Convert to wide format to compute effect
te_by_group <- profits_by_group |>
# Convert column values of consultant to headers and take values from
# mean_profit
pivot_wider(
# For each group, we want one row
id_cols = "group",
# Values of consultants to headers
names_from = "consultant",
# Take values from 'mean_profit'
values_from = "mean_profit",
# Change names of headers for better readability
names_prefix = "consultant_",
) |>
# Compute group treatment effect by subtracting mean of untreated units from
# mean of treated units
mutate(te = consultant_1 - consultant_0)
# Show table
print(te_by_group)
# Taking the average of the treatment effect column. Same as weighted mean,
# because group sizes are identical.
mean(te_by_group$te)
# With weighted mean
weighted.mean(te_by_group$te, w = c(250,250,250,250))
# Split group into n equally sized groups
profits$group <- ntile(profits$previous_profit, 4)
# Compute mean value and number of observations by group
profits_by_group <- profits |>
# What columns to group by
group_by(group, consultant) |>
# What columns to use for aggregation and what kind of aggregations
summarise(
# Average profit by group
mean_profit = mean(profit)
# Number of observations by group
n = n()
# Split group into n equally sized groups
profits$group <- ntile(profits$previous_profit, 4)
# Compute mean value and number of observations by group
profits_by_group <- profits |>
# What columns to group by
group_by(group, consultant) |>
# What columns to use for aggregation and what kind of aggregations
summarise(
# Average profit by group
mean_profit = mean(profit),
# Number of observations by group
n = n()
) |>
# Remove grouping structure
ungroup()
# Show table
print(profits_by_group)
# Naive estimate
profits |>
group_by(consultant) |>
summarise(mean_profit = mean(profit)) |>
ungroup()
readRDS("/Users/oli/my_drive/02_TUHH/03_github/_ss24_cds_assignments/ss24_cds_week_2/health_program.rds")
health <- readRDS("/Users/oli/my_drive/02_TUHH/03_github/_ss24_cds_assignments/ss24_cds_week_2/health_program.rds")
sick_days_by_group <- health |>
# What columns to group by
group_by(group_1, group_2) |>
# What columns to use for aggregation and what kind of aggregations
summarise(
# Average profit by group
mean_profit = mean(profit),
# Number of observations by group
nobs = n()
) |>
# Remove grouping structure
ungroup()
library(tidyverse)
# Compute mean value and number of observations by group
sick_days_by_group <- health |>
# What columns to group by
group_by(group_1, group_2) |>
# What columns to use for aggregation and what kind of aggregations
summarise(
# Average profit by group
mean_profit = mean(profit),
# Number of observations by group
nobs = n()
) |>
# Remove grouping structure
ungroup()
# Split group into n equally sized groups
health$group_1 <- ntile(health$sick_days, n = 4)
health$group_2 <- ntile(health$age, n = 4)
# Compute mean value and number of observations by group
sick_days_by_group <- health |>
# What columns to group by
group_by(group_1, group_2) |>
# What columns to use for aggregation and what kind of aggregations
summarise(
# Average profit by group
mean_profit = mean(profit),
# Number of observations by group
nobs = n()
) |>
# Remove grouping structure
ungroup()
# Compute mean value and number of observations by group
sick_days_by_group <- health |>
# What columns to group by
group_by(group_1, group_2) |>
# What columns to use for aggregation and what kind of aggregations
summarise(
# Average profit by group
mean_profit = mean(sick_days),
# Number of observations by group
nobs = n()
) |>
# Remove grouping structure
ungroup()
sick_days_by_group
te_by_group <- profits_by_group |>
# Convert column values of consultant to headers and take values from
# mean_profit
pivot_wider(
# For each group, we want one row
id_cols = c("group_1", "group_2"),
# Values of consultants to headers
names_from = "consultant",
# Take values from 'mean_profit'
values_from = "mean_profit",
# Change names of headers for better readability
names_prefix = "consultant_"
) |>
# Compute group treatment effect by subtracting mean of untreated units from
# mean of treated units
mutate(te = consultant_1 - consultant_0)
te_by_group <- sick_days_by_group |>
# Convert column values of consultant to headers and take values from
# mean_profit
pivot_wider(
# For each group, we want one row
id_cols = c("group_1", "group_2"),
# Values of consultants to headers
names_from = "consultant",
# Take values from 'mean_profit'
values_from = "mean_profit",
# Change names of headers for better readability
names_prefix = "consultant_"
) |>
# Compute group treatment effect by subtracting mean of untreated units from
# mean of treated units
mutate(te = consultant_1 - consultant_0)
te_by_group <- sick_days_by_group |>
# Convert column values of consultant to headers and take values from
# mean_profit
pivot_wider(
# For each group, we want one row
id_cols = c("group_1", "group_2"),
# Values of consultants to headers
names_from = "health_program",
# Take values from 'mean_profit'
values_from = "mean_profit",
# Change names of headers for better readability
names_prefix = "health_program_"
) |>
# Compute group treatment effect by subtracting mean of untreated units from
# mean of treated units
mutate(te = consultant_1 - consultant_0)
# Compute mean value and number of observations by group
sick_days_by_group <- health |>
# What columns to group by
group_by(group_1, group_2, health_program) |>
# What columns to use for aggregation and what kind of aggregations
summarise(
# Average profit by group
mean_profit = mean(sick_days),
# Number of observations by group
nobs = n()
) |>
# Remove grouping structure
ungroup()
te_by_group <- sick_days_by_group |>
# Convert column values of consultant to headers and take values from
# mean_profit
pivot_wider(
# For each group, we want one row
id_cols = c("group_1", "group_2"),
# Values of consultants to headers
names_from = "health_program",
# Take values from 'mean_profit'
values_from = "mean_profit",
# Change names of headers for better readability
names_prefix = "health_program_"
) |>
# Compute group treatment effect by subtracting mean of untreated units from
# mean of treated units
mutate(te = consultant_1 - consultant_0)
te_by_group <- sick_days_by_group |>
# Convert column values of consultant to headers and take values from
# mean_profit
pivot_wider(
# For each group, we want one row
id_cols = c("group_1", "group_2"),
# Values of consultants to headers
names_from = "health_program",
# Take values from 'mean_profit'
values_from = "mean_profit",
# Change names of headers for better readability
names_prefix = "health_program_"
) |>
# Compute group treatment effect by subtracting mean of untreated units from
# mean of treated units
mutate(te = health_program_1 - health_program_0)
sick_days_by_group |>
# Convert column values of consultant to headers and take values from
# mean_profit
pivot_wider(
# For each group, we want one row
id_cols = c("group_1", "group_2"),
# Values of consultants to headers
names_from = "health_program",
# Take values from 'mean_profit'
values_from = "mean_profit",
# Change names of headers for better readability
names_prefix = "health_program_"
)
te_by_group <- sick_days_by_group |>
# Convert column values of consultant to headers and take values from
# mean_profit
pivot_wider(
# For each group, we want one row
id_cols = c("group_1", "group_2"),
# Values of consultants to headers
names_from = "health_program",
# Take values from 'mean_profit'
values_from = "mean_profit",
# Change names of headers for better readability
names_prefix = "health_program_"
) |>
# Compute group treatment effect by subtracting mean of untreated units from
# mean of treated units
mutate(te = health_program_TRUE - health_program_FALSE)
te_by_group
sick_days_by_group
sick_days_by_group |> view()
health$health_program <- as.numeric(health$health_program)
health
health <- readRDS("/Users/oli/my_drive/02_TUHH/03_github/_ss24_cds_assignments/ss24_cds_week_2/health_program.rds")
health$health_program <- as.numeric(health$health_program)
health
saveRDS(health, "/Users/oli/my_drive/02_TUHH/03_github/_ss24_cds_assignments/ss24_cds_week_2/health_program.rds")
readRDS("/Users/oli/my_drive/02_TUHH/03_github/_ss24_cds_assignments/ss24_cds_week_2/health_program.rds")
